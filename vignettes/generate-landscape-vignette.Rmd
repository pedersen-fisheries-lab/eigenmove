---
title: "Generating landscapes and computing patches with a simple random walk movement model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{generate-landscape-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
library(eigenmove)
```

In this vignette you will see a complete example of eigenmove's capabilities. We will show you how to generate a toy landscape using Gaussian Processes (`create_GP_landscape()`) and how to compute random walks on that landscape according to a simple movement model (`load_landscape()`, `calc_step()`, `rescale_landscape()`). This will result in a *dispersal matrix* which can then be processed through the core `eigenmove` functionality of estimating patches on a landscape. If you already have a dispersal matrix and just want to skip to estimating patches, see `vignette("eigenmove-vignette")`.

### Creating a toy landscape

Use `create_GP_landscape()` to simulate a toy landscape via a Gaussian process for use with simple random walk movement model. A Gaussian process (GP) assumes that a random value at each point in the landscape follows a normal distribution, and random values for points close to one another are correlated, so they have similar values. For more information on GPs see this article: https://distill.pub/2019/visual-exploration-gaussian-processes/.

```{r}
set.seed(1)
small_landscape <- create_GP_landscape(
  landscape_width = 32, # width in pixels
  landscape_height = 32, # height in pixels
  patch_scale = 1 # size of patches
)
```

This generates a dataframe with 3 columns: an x-coordinate a y-coordinate and a Gaussian process-generated intensity value for each point of a landscape. To convert this "intensity" into simple low, mid and high "habitat qualities" we can run `rescale_landscape()` to generate a new column (`type`) based on the generated values.

```{r}
small_landscape$type <- rescale_landscape(small_landscape$intensity)
```

We can plot this data by mapping the coordinates as pixel locations with the darkness of each pixel representing the three habitat qualities (types). White pixels are low quality, grey pixels are mid quality and black pixels are high quality.

```{r}
library(ggplot2)

small_landscape_plot <- ggplot(
  small_landscape, aes(x, -y, fill = type)) +
  geom_tile(color="lightgrey") +
  scale_fill_manual("Habitat quality",
                    values = c("white","grey","black")) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5),
        panel.border = element_rect(colour = "grey", fill=NA, linewidth=0.5))
small_landscape_plot
```
